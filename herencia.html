<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Herencia</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <nav><a href="index.html"></a></nav>
    <h1>Herencia</h1>
    <h2>¿Qué es la herencia y auáles son los aspectos básicos?</h2>
    <p>
        La herencia en Java se refiere a la capacidad de una clase (llamada subclase o clase derivada o hija) de heredar
        atributos y métodos de otra clase (llamada superclase o clase base o padre). Esto permite la reutilización de
        código y la creación de una jerarquía de clases en la que las subclases heredan comportamientos y
        características
        de las superclases. Aquí hay algunos conceptos clave relacionados con la herencia en Java:
    </p>
    <p>
        <strong>Clases Base, clases padre o (Superclases)</strong>: Es la clase original de la que otras clases heredan. Contiene
        atributos y métodos comunes que se comparten con sus subclases. Puede considerarse como la clase "padre" en la jerarquía.
    </p>
    <p>
        <strong>Clase Derivada, Subclase o clase hija</strong>: Es la clase que hereda atributos y métodos de la clase base. Puede
        agregar
        nuevos atributos y métodos o modificar los heredados. Se considera la clase "hija" en la jerarquía.
    </p>
    <p>
        <strong>Extends</strong>: En Java, para establecer una relación de herencia, se utiliza la palabra clave extends. Una subclase se
        declara usando extends seguido del nombre de la superclase. Por ejemplo: class Subclase extends Superclase.
    </p>
    <p>
        <strong>Métodos y Atributos Heredados</strong>: Las subclases heredan todos los métodos y atributos (campos) públicos o
        protegidos de
        la superclase. Esto significa que pueden acceder y utilizar estos métodos y atributos directamente.
    </p>
    <p>

        <strong>Métodos Override</strong>: Una subclase puede proporcionar su propia implementación de un método heredado de la
        superclase.
        Esto se logra anotando el método con la etiqueta @Override y proporcionando una nueva implementación.
    </p>
    <p>
        <strong>Herencia en Cadena</strong>: Una subclase puede a su vez convertirse en una superclase para otra clase, creando una
        cadena de
        herencia. Esto permite la construcción de jerarquías complejas de clases.
    </p>
    <p>
        <strong>Acceso a Constructores</strong>: Las subclases pueden llamar al constructor de la superclase utilizando la palabra clave
        super para inicializar las propiedades heredadas de la superclase.
    </p>
    <p>
        La herencia en Java es una poderosa herramienta para la reutilización de código y la creación de una estructura
        organizada de clases en una aplicación. Sin embargo, es importante usarla con sensatez y asegurarse de que la
        relación de herencia tiene sentido en el contexto de tu aplicación, ya que una jerarquía de clases excesivamente
        compleja puede volverse difícil de mantener.
    </p>
    <p>A diferencia con otros lenguajes como C++ no existe una herencia multiple, por lo que sólo se podrá heredar metodos y atributos
        de una sola clase.
    </p>

    <h2>Construcción: extends y ejemplos:</h2>
    <section>
        <p>Para construir una jerarquica de dependencia entre una clase y otra se utilza la palabra clave extends
            después del nombre de la clase cuya dependencia depende de otra clase. Por ejemplo:
        </p>
        <code>

            public class Padre{};
            public class Hijo extends Padre{}
        </code>
        <p>En UML se representa con un flecha continua que va desde la clase hija a la clase padre, con una flecha en
            blanco.</p>
        <p>Se puede realizar mediante dos métodos: generación y especialización.</p>
        <p>Hay que seguir el principio Open - Close. Abierto a la extension y cerrado a la modificación.</p>
        <p>Una clase hija puede ejecutar constructor o métodos de la clase padre a traves de la palabra reservada super.
        </p>
        <p>Si queremos capar o cortar los ovarios o los testitulos a una clase esto ser haría mediante la palabra final.
            O bien en
            la misma clase o bien para algún método, constructor o atributo en particular.
        </p>
    
        <p>Cuando una clase hereda de otra también puede ser del tipo padre. Pero habría que hacer un cast</p>
        <p>Por ejemplo:</p>
        <code>
            Hijo hijo = (Hijo) new Padre();
        </code>
        <p>Un padre puede instanciarse con su Hijo aunque luego hará falta una conversion. Aunque lo aconsejable es que
            sea del tipo
            del cual se esta creando.
        </p>
        <code>
            Padre padreConvertido = new Hijo();
            padreConvertido.setNombre("Juan");
            System.out.println(((Hijo) padreConvertido).tituloget());
        </code>
        <p>Un Hijo también hereda todos los atributos y métodos que herede su padre.</p>
        <p>Para saber el ancestro se utiliza el método getSuperclass()</p>
        <p>Una clase hija deberá impementar el constructor de la clase padre si este no posee un constructor por
            defecto, es decir, un
            constructor sin parametros. Esto se hará en el constructor hijo con la palabra reservada super().
        </p>
        <code>
            Constructor(){
                super(paramClasePadre);
                //etc code
            }
        </code>
    </section>
    <h2>Sobreescribir métodos de las clases padres</h2>
    <section>
        <p>Se puede sobreescrir métodos utilizando el mismo nombre con la notación @Override</p>
        <p>Podemos aprovechar parte del metodos padre con la palabra super().metodoPadre</p>
    </section>
    <h2>Clases abstractas:</h2>
    <section>
        <p>En ocasiones se necesitará crear una superclase que solamente defina una forma generalizada o plantilla de
            algunos métodos
            o propiedades. Dicha super-clase obligará a las subclases a implementar aquellas propiedades o métodos que
            no esten definidos
            y que necesiten implementarse.
        </p>
        <p>Por ejemplo:</p>
        <code>
            abstract public class Nameclass{...}
            public abstract class Nameclass{...}
            abstract public void metodo() //Sin  llaves
            public abstract String medodo()//Sin llaves
        </code>
        <p>Una clase abstracta puede tener uno o varios métodos abstractos.</p>
        <p>Una clase abstracta no se puede instanciar sin implementar sus métodos.</p>
    </section>
    <h2>Evitar herencia con final</h2>
    <section>
        <p>Ocurriría lo mismo con aquellos métodos que fueran final. Estos métodos no podrían heredarse.</p>
        <code>
            public final ClaseSinHerederos{ ...  }
            public final void metodo(){ ... }
        </code>
        <p>No se puede instanciar una clase abstracta.</p>
    </section>
    <h2>UML</h2>
    <section>
        <p>Las clases que heredan de una clase y sobreescribe cualquier método, este hay describirlo en el diagrama.</p>
        <p>Los métodos estaticos se subrayan</p>
        <p>Las clases con las que tienen dependencia se hace una linea punteada.</p>
    </section>
    <h2>Clases anonimas</h2>
    <p>Es la instanciación de interfaces o clases abstractas implementando todos sus métodos en una misma instancia.</p>
    <p>as clases anónimas en Java son una forma de crear clases en el lugar donde se necesitan, sin necesidad de darles
        un nombre. Estas clases se utilizan comúnmente para implementar interfaces o clases abstractas de manera concisa
        y directa. Las clases anónimas son útiles cuando solo se necesita una implementación de una interfaz o una
        subclase en un lugar específico del código y no se desea crear una clase con nombre completo.</p>

    <p>Por ejemplo:</p>
    <code>
        public class ClasePrincipal {
            public static void main(String[] args) {
                MiInterfaz miObjeto = new MiInterfaz() {
                    @Override
                    public void metodoInterfaz() {
                        System.out.println("Implementación del método en una clase anónima.");
                    }
                };
        
                miObjeto.metodoInterfaz(); // Llama al método de la clase anónima
            }
        }
        
        interface MiInterfaz {
            void metodoInterfaz();
        }
        
    </code>
    <p>Características clave de las clases anónimas en Java:</p>
    <ul>
        <li>
            No tienen nombre: A diferencia de las clases regulares, las clases anónimas no tienen un nombre de clase
            definido.
        </li>
        <li>
            Se definen y se crean en el lugar: Las clases anónimas se definen y se crean directamente en el lugar donde
            se
            necesitan, en general, como argumentos de métodos o inicializadores de variables.
        </li>
        <li>
            Implementan interfaces o extienden clases abstractas: Las clases anónimas suelen utilizarse para implementar
            interfaces o extender clases abstractas.
        </li>
    </ul>
    <p>Las clases anónimas son útiles para escribir código más conciso y mantener la implementación específica de una
        interfaz o clase abstracta cerca de donde se utiliza, evitando la necesidad de crear una clase con nombre
        independiente.</p>

</body>

</html>